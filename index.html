<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />

<meta name="viewport"
  content="width=device-width, initial-scale=1, viewport-fit=cover, user-scalable=no" />
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black">
<meta name="theme-color" content="#3B82F6">
<link rel="manifest" href="manifest.json">
<link rel="apple-touch-icon" sizes="192x192" href="icon/icon_192.png">

<title>あいうえお よんで！</title>
<style>

/* はみ出し防止の基本 */
*,*::before,*::after{ box-sizing:border-box; min-width:0; }
.panel, .boardWrap{ min-width:0; }   /* 列の縮小を許可 */

 :root{
  --panelW:300px;
  --panelCellH: 48px;
  --panelCellFS: 16px;
  --panelGap: 12px;
    --ink:#111; --muted:#dfe5ea;
    --key:72px; --gap:10px;
    --okSize:72px;
    /* 初期テーマ：あお */
    --bg-strong:#e7f0ff; --accent:#3B82F6; --accentDark:#1E40AF;
    --wall:none; --wallOpacity:0; /* 📷カスタム背景 */
  }
 html,body{
   height:100%;margin:0;
   background-color: var(--bg-strong);
   background-image: var(--wall),
    linear-gradient(rgba(255,255,255,var(--wallOpacity)),rgba(255,255,255,var(--wallOpacity)));
   background-size: cover; background-position:center;
   color:var(--ink);
   font-family:system-ui,-apple-system,BlinkMacSystemFont,"Hiragino Kaku Gothic ProN","Yu Gothic","Noto Sans JP",sans-serif;
}
  
.app {
  position: relative;
  padding-bottom: 0;
  padding-bottom: constant(safe-area-inset-bottom);
  padding-bottom: env(safe-area-inset-bottom);
  height: 100svh;
  display: grid;
  grid-template-rows: auto auto 1fr;
  overflow: hidden;
}

@supports not (height: 100svh) {
  .app { height: 100vh; }
}

  header{padding:8px 12px}
  .display{margin:6px 12px;background:#fff;border:2px solid var(--muted);border-radius:16px;
    padding:12px;min-height:calc(var(--key)*0.9);font-size:calc(var(--key)*0.5);line-height:1.4;word-wrap:break-word}

header h1 {
  position: relative;
  font-size: 2.0em;
  font-weight: 900;
  display: flex;
  gap: 0.5em;           /* 文字の間隔 */
  justify-content: center;
}

header h1 span {
  position: relative;
  z-index: 1;           /* 文字を最前面に */
}

header h1 span::before {
  content: "";
  position: absolute;
  inset: -0.5em;       /* 丸の大きさ調整 */
  border-radius: 65%;   /* 丸にする */
  background: var(--accent);  /* 各テーマ色に追従 */
  z-index: -1;          /* 背景に置く */
}

.deck{
  display:grid;
  grid-template-columns: minmax(0,1fr) minmax(0,var(--panelW));
  gap:12px;
  padding:8px 12px 12px;
  height:100%;
  min-height:0;
  overflow:hidden;
}

  /* 画面が狭い/縦のときはパネルを下に回して1カラムに */
@media (max-width: 850px) {
  .deck {
    grid-template-columns: 1fr;
    grid-template-rows: 1fr auto;   /* キーボードを優先で広く */
  }
  .panel { order: 2; }              /* パネルを下に */
  .boardWrap { order: 1; }
}
  
.panel,.boardWrap{
  background:rgba(255,255,255,.70);
  border:3px solid var(--muted);
  border-radius:18px;
  padding:12px;
  height:100%;
  min-height:0;
}

.panel{
  display: flex;
  flex-direction: column;
  gap: var(--panelGap);
  overflow: auto;
}
.panel > .sliders {
  margin-top: auto;
  margin-bottom: auto;
}

.g3{display:grid;grid-template-columns:repeat(3,1fr);gap:var(--panelGap);}

.theme-controls {
  display: flex;
  flex-direction: column;
  gap: var(--panelGap);
}
.theme-grid {
  display: grid;
  grid-template-columns: repeat(5, 1fr);
  gap: 8px;
}
.themeBtn {
  aspect-ratio: 1 / 1;
  border-radius: 50%;
  border: 3px solid var(--muted);
  cursor: pointer;
  height: var(--panelCellH); 
  width:auto; aspect-ratio: unset;
}
#tRed    { background-color: #E84C3D; }
#tBlue   { background-color: #3B82F6; }
#tYellow { background-color: #ECA400; }
#tGreen  { background-color: #20C997; }
#tPink   { background-color: #E91E63; }

.customBtn {
  height: var(--panelCellH);
  border: 2px solid var(--accent);  /* ← テーマ連動 */
  background: #fff;
  color: #234;
  border-radius: 14px;
  font-weight: 900;
  font-size: var(--panelCellFS);
  display: grid;
  place-items: center;
  cursor: pointer;
}
.fileInput { display: none; }

/* ▼ 声セクション：2列=同じ幅に、色はテーマ連動 */
.voiceGrid{
  display:grid;
  grid-template-columns: 1fr 1fr;   /* ← 同じ幅の2列 */
  gap: var(--panelGap);
}
.voiceGrid select,
.voiceGrid button{
  height: var(--panelCellH);
  font-weight:800;
  font-size: var(--panelCellFS);
  width: 100%;
}

/* セレクトの枠やゴースト系ボタンの枠をテーマ色に */
.voiceGrid select{
  grid-column: auto;                /* ← span解除して1列分に */
  border:2px solid var(--accent);   /* ← テーマ連動 */
  border-radius:14px;
  background:#fff;
  color:#234;
  padding:0 10px;
}
.voiceGrid .btn.ghost{
  background:#fff;
  color:#234;
  border:2px solid var(--accent);   /* ← テーマ連動 */
}
/* ▼ iOSで角丸が効かない対策：外観リセット＋角丸を強制 */
.voiceGrid .btn,
.voiceGrid .btn.ghost,
#reloadVoiceBtn {
  -webkit-appearance: none;
  appearance: none;
  border-radius: 14px;          /* 角丸を確実に */
  border: 2px solid var(--accent);
  background: #fff;
  color: #234;
}
.voiceGrid .btn,
#reloadVoiceBtn { width: 100%; 
}

.charToggle{
  border:3px solid #bfc9d7;
  background:#fff; color:#234;
  border-radius:16px;
  font-weight:900;
  transition: background-color .2s, color .2s, border-color .2s;
}
.actionRow .charToggle {
    grid-column: 4 / span 3;
    height: var(--okSize);
    font-size: calc(var(--key) * 0.28);
}
.actionRow .charToggle.on{
  background-color: var(--accentDark);
  color: #fff;
  border-color: var(--accentDark);
  box-shadow: none;
}

  .tenkey{display:grid;grid-template-columns:repeat(3,1fr);gap:12px}
  .nkey{
    width:100%;
    height:clamp(58px, calc(var(--panelW)/3 - 16px), 96px);
    border:2px solid var(--accent);border-radius:16px;background:#fff;font-weight:900;
    font-size:calc(var(--key)*0.5);color:#111; box-shadow:0 2px 0 rgba(0,0,0,.06)
  }
  .nkey.zero{grid-column:2}

  .editRow{display:grid;grid-template-columns:1fr 1fr;gap:12px}
  .editBtn{
    height:var(--okSize); border-radius:16px; font-weight:900; font-size:18px;
    border:3px solid var(--accentDark); background:#fff; color:#000
  }
  .editBtn.primary{ background:var(--accentDark); color:#fff }

  .boardWrap{display:grid;grid-template-rows:auto 8px auto 8px auto;gap:0;overflow:hidden}
  
  .kanaGrid{
    display:grid;
    grid-template-columns:repeat(10,var(--key));
    gap:var(--gap);
    border-bottom: 2px solid var(--muted);
    padding-bottom: var(--gap);
  }
  .col{display:grid;grid-auto-rows:var(--key);gap:var(--gap)}
  .symRow{display:grid;grid-template-columns:repeat(10,var(--key));gap:var(--gap);align-items:center}

  .actionRow{display:grid;grid-template-columns:repeat(10,var(--key));gap:var(--gap);align-items:center}
  
  #questionKey {
    grid-column: 1 / span 1;
  }
  .spaceKey{
    grid-column: 2 / span 2;
    height:var(--okSize);
    border:2px solid #cfd7df;border-radius:16px;font-weight:900;
    font-size:calc(var(--key)*0.35);color:#111;
  }
  .okKey{
    grid-column: 7 / -1; 
    height:var(--okSize);
    border: 5px solid var(--accent);
    border-radius:20px;
    font-weight:900;
    font-size:calc(var(--key)*0.5);
    background:var(--accentDark);
    color:#fff;
    transition:background .08s,color .08s,transform .08s;
  }
  .okKey:active{ background:#fff; color:#000; transform:scale(.98) }

  .key{
    width:var(--key);height:var(--key);border:2px solid #cfd7df;border-radius:16px;
    display:grid;place-items:center;font-weight:900;font-size:calc(var(--key)*0.5);color:#111;box-shadow:0 2px 0 rgba(0,0,0,.08);
    cursor:pointer
  }

  .theme-red   { --bg-strong:#ffe3e3; --accent:#E84C3D; --accentDark:#C0392B }
  .theme-blue  { --bg-strong:#e7f0ff; --accent:#3B82F6; --accentDark:#1E40AF }
  .theme-yellow{ --bg-strong:#fff4bf; --accent:#ECA400; --accentDark:#B58100 }
  .theme-green { --bg-strong:#e6ffe6; --accent:#20C997; --accentDark:#0E9F6E }
  .theme-pink  { --bg-strong:#ffe0ef; --accent:#E91E63; --accentDark:#AD1457 }

  select{appearance:none}
  
  html, body, button { touch-action: manipulation; }
  
  .sliders{display:grid;grid-template-columns:80px 1fr;gap:12px 18px;align-items:center}
  .sliders label{text-align:center;line-height: 1.3;font-size: 14px;color:#444;font-weight:600;}
  input[type="range"]{width:100%;-webkit-appearance:none;height:14px;background:#e6eef7;border-radius:999px; outline:none;}
  input[type="range"]::-webkit-slider-thumb{-webkit-appearance:none;width:34px;height:34px;border-radius:50%;background:#fff;border:3px solid var(--accent)}
  input[type="range"]::-moz-range-thumb{width:34px;height:34px;border-radius:50%;background:#fff;border:3px solid var(--accent)}
  
#animation-overlay {
  position: absolute;
  top: 0; left: 0;
  width: 100%; height: 100%;
  pointer-events: none;
  overflow: hidden;
  z-index: 999;
}
.emoji-float {
  position: absolute;
  bottom: -50px;
  font-size: 48px;
  animation-name: float-up;
  animation-timing-function: ease-out;
  animation-iteration-count: 1;
}

@keyframes float-up {
  0% { transform: translateY(0) scale(1); opacity: 1; }
  100% { transform: translateY(-80vh) scale(1.5); opacity: 0; }
}

  /* ===== スマホ〜小さめiPad縦向け: 900px以下で1カラムに ===== */
@media (max-width: 900px) {
  /* タイトルは自動で小さく＆折り返し可に */
  header h1 {
    font-size: clamp(18px, 4.5vw, 28px);
    flex-wrap: wrap;
    gap: 0.35em;
  }
  header h1 span::before {
    inset: -0.4em;              /* 丸の大きさを少し小さめに */
    border-radius: 999px;
  }

  /* 右パネルを下に：デッキは1カラム */
  .deck {
    grid-template-columns: 1fr;
    gap: 10px;
    padding: 8px 10px 10px;
    overflow: auto;             /* 縦スクロールを許可 */
  }
  /* パネルは高さを自動に（はみ出し防止） */
  .panel {
    height: auto;
    max-height: none;
  }

  /* 余白を少し詰める */
  :root {
    --panelGap: 10px;
    --gap: 8px;
  }

  /* 表示欄も少しだけ低く・文字も自動縮小 */
  .display{
    min-height: calc(var(--key) * 0.8);
    font-size: clamp(16px, calc(var(--key) * 0.45), 24px);
  }

  /* 下アクション列の高さをやや低く */
  .spaceKey, .okKey, .actionRow .charToggle {
    height: calc(var(--okSize) * 0.9);
  }
}

/* ===== さらに狭いiPhone系（480px以下）の微調整 ===== */
@media (max-width: 480px) {
  :root{
    --gap: 6px;
  }
  .display{
    min-height: calc(var(--key) * 0.7);
    font-size: clamp(14px, calc(var(--key) * 0.4), 20px);
  }
  .sliders label{ font-size: 12px; line-height: 1.2; }
  .nkey { height: clamp(52px, calc(var(--panelW)/3 - 18px), 88px); }
}
  /* 縦向きブロック用オーバーレイ（初期は非表示） */
#rotateGate{
  position: fixed; inset: 0;
  display: none;
  place-items: center;
  background: rgba(255,255,255,.92);
  z-index: 2000;
}
#rotateGate .rotateBox{
  padding: 24px 28px;
  border: 3px solid var(--accent);
  border-radius: 16px;
  background: #fff;
  font-weight: 900;
  font-size: clamp(18px, 3.2vw, 28px);
  text-align: center;
  box-shadow: 0 8px 20px rgba(0,0,0,.12);
}

/* body に .portrait が付いたらアプリ本体を隠してゲートを出す */
body.portrait .app{ visibility: hidden; }
body.portrait #rotateGate{ display: grid; }

</style>
</head>
<body class="theme-blue">
<div class="app">
  <div id="animation-overlay"></div>

 <header>
  <h1>
    <span>あ</span><span>い</span><span>う</span><span>え</span><span>お</span><span>🤩</span>
    <span>よ</span><span>ん</span><span>で</span><span>！</span>
  </h1>
</header>

  <div class="display" id="display" aria-live="polite"></div>

  <div class="deck" id="deck">
    <section class="boardWrap">
      <div class="kanaGrid" id="kanaGrid"></div>
      <div></div>
      <div class="symRow" id="symRow"></div>
      <div></div>
      <div class="actionRow">
        <button class="key" id="questionKey">？</button>
        <button class="spaceKey" id="spaceBtn">スペース</button>
        <button class="charToggle" id="charToggleBtn">ひともじずつよむ</button>
        <button class="okKey" id="okActionBtn">よんで！</button>
      </div>
    </section>

    <aside class="panel">
      <div class="theme-controls">
        <div class="theme-grid">
          <button class="themeBtn" id="tRed" aria-label="テーマ 赤"></button>
          <button class="themeBtn" id="tBlue" aria-label="テーマ 青"></button>
          <button class="themeBtn" id="tYellow" aria-label="テーマ 黄色"></button>
          <button class="themeBtn" id="tGreen" aria-label="テーマ 緑"></button>
          <button class="themeBtn" id="tPink" aria-label="テーマ ピンク"></button>
        </div>
        <div class="g3">
            <label class="customBtn" for="bgPicker" style="grid-column: 1 / 3;">🖼️はいけいをえらぶ</label>
            <button class="customBtn" id="bgResetBtn">リセット</button>
        </div>
        <input id="bgPicker" class="fileInput" type="file" accept="image/*">
      </div>

      <div class="g3 voiceGrid">
        <select id="voiceSelect" aria-label="音声選択"></select>
        <button class="btn ghost" id="reloadVoiceBtn">リロード</button>
      </div>
      
      <div class="sliders">
        <label>こえの<br>はやさ</label><input type="range" id="rate" min="0.7" max="1.5" step="0.05" value="1.0">
        <label>こえの<br>たかさ</label><input type="range" id="pitch" min="0.7" max="1.6" step="0.05" value="1.0">
      </div>

      <div class="tenkey" id="tenkey"></div>

      <div class="editRow">
        <button class="editBtn primary" id="backspaceBtn">ひともじ<br>けす</button>
        <button class="editBtn" id="clearBtn">ぜんぶけす</button>
      </div>
    </aside>
</div>

<script>
(function(){
  const display = document.getElementById('display');
  const rootStyle = document.documentElement.style;

  const cols = {
    "あ":["あ","い","う","え","お"], "か":["か","き","く","け","こ"],
    "さ":["さ","し","す","せ","そ"], "た":["た","ち","つ","て","と"],
    "な":["な","に","ぬ","ね","の"], "は":["は","ひ","ふ","へ","ほ"],
    "ま":["ま","み","む","め","も"], "や":["や","","ゆ","","よ"],
    "ら":["ら","り","る","れ","ろ"], "わ":["わ","","を","","ん"]
  };
  const order = ["わ","ら","や","ま","は","な","た","さ","か","あ"];
  const kanaGrid = document.getElementById('kanaGrid');

  const symRow = document.getElementById('symRow');
  const SYMBOLS = ["゛","゜","ゃ","ゅ","ょ","っ","ー","、","。","！"];

  const PALETTES = {
    red:["#FF6B6B","#FF8E4D","#FF3D5A","#FFB04D","#E84C3D","#FF7043"],
    blue:["#4D9BFF","#22B8FF","#3B82F6","#00B8D9","#5C7CFA","#4DD0E1"],
    yellow:["#FFC93C","#FFB300","#FFD166","#ECA400","#FF9F1C","#F9C74F"],
    green:["#2ECC71","#20C997","#7BD88A","#00C853","#2ABF88","#1ABC9C"],
    pink:["#FF6FAE","#FF4DA6","#FF8BCB","#E91E63","#FF5D8F","#FF85B3"]
  };
  const BG = { red:"#ffe3e3", blue:"#e7f0ff", yellow:"#fff4bf", green:"#e6ffe6", pink:"#ffe0ef" };

  function speakCharacter(char) {
    if (!char) return;
    setTimeout(() => sayOnce(char, { rate: 1.2, pitch: 1.1 }), 50);
  }

  function makeKey(ch, onClick){
    const b=document.createElement('button'); b.className='key'; b.textContent=ch;
    b.addEventListener('click',()=>onClick(ch),{passive:true}); return b;
  }
  function buildKana(){
    kanaGrid.innerHTML="";
    order.forEach(name=>{
      const col=document.createElement('div'); col.className='col';
      cols[name].forEach(k=>{
        if(k===""){ const s=document.createElement('div'); s.style.width='var(--key)'; s.style.height='var(--key)'; s.style.visibility='hidden'; col.appendChild(s); }
        else col.appendChild(makeKey(k, insertText));
      });
      kanaGrid.appendChild(col);
    });
  }
  function buildSymbols(){ symRow.innerHTML=""; SYMBOLS.forEach(s=> symRow.appendChild(makeKey(s, handleSymbol))); }
  
  function insertText(t){
    display.textContent += t;
    speakCharacter(t);
  }
  const daku={"か":"が","き":"ぎ","く":"ぐ","け":"げ","こ":"ご","さ":"ざ","し":"じ","す":"ず","せ":"ぜ","そ":"ぞ","た":"だ","ち":"ぢ","つ":"づ","て":"で","と":"ど","は":"ば","ひ":"び","ふ":"ぶ","へ":"べ","ほ":"ぼ"};
  const hand={"は":"ぱ","ひ":"ぴ","ふ":"ぷ","へ":"ぺ","ほ":"ぽ"};
  const rd=Object.fromEntries(Object.entries(daku).map(([k,v])=>[v,k]));
  const rh=Object.fromEntries(Object.entries(hand).map(([k,v])=>[v,k]));
  
  function handleSymbol(s){
    if(s==="゛"||s==="゜"){
      const arr=[...display.textContent]; if(!arr.length) return;
      const last=arr[arr.length-1];
      const rep=(s==="゛")?(daku[last]||rd[last]):(hand[last]||rh[last]);
      if(rep){
        arr[arr.length-1]=rep;
        display.textContent=arr.join('');
        speakCharacter(rep);
      }
      return;
    }
    insertText(s);
  }

  function buildTenkey(){
    const tk=document.getElementById('tenkey'); tk.innerHTML="";
    ["1","2","3","4","5","6","7","8","9","","0",""].forEach(v=>{
      if(!v){ tk.appendChild(document.createElement('div')); return; }
      const b=document.createElement('button'); b.className='nkey'; b.textContent=v;
      if(v==="0") b.classList.add('zero');
      b.addEventListener('click',()=>insertText(v),{passive:true});
      tk.appendChild(b);
    });
  }

  function paintKeys(palette){
    const keys=document.querySelectorAll('.key, #questionKey');
    let i=0; keys.forEach(k=>{ k.style.backgroundColor = palette[i++ % palette.length]; });
    document.getElementById('spaceBtn').style.backgroundColor = palette[i % palette.length];
    document.querySelectorAll('.nkey').forEach((n,idx)=>{ n.style.backgroundColor = palette[(i+idx) % palette.length]; });
  }
  function setTheme(name){
    document.body.className = `theme-${name}`;
    rootStyle.setProperty('--bg-strong', BG[name]);
    paintKeys(PALETTES[name]);
  }

/* 📷カスタム背景 */
const bgPicker = document.getElementById('bgPicker');

// 画像選択時に base64 で保存
bgPicker.addEventListener('change', (e)=>{
  const f = e.target.files && e.target.files[0]; if(!f) return;
  const reader = new FileReader();
  reader.onload = () => {
    const dataUrl = reader.result; // base64
    localStorage.setItem('bgImage', dataUrl);
    document.documentElement.style.setProperty('--wall', `url("${dataUrl}")`);
    document.documentElement.style.setProperty('--wallOpacity', .10);
  };
  reader.readAsDataURL(f);
});

// 起動時に復元
const saved = localStorage.getItem('bgImage');
if (saved) {
  document.documentElement.style.setProperty('--wall', `url("${saved}")`);
  document.documentElement.style.setProperty('--wallOpacity', .10);
}

// 背景リセットボタンの機能を追加
const bgResetBtn = document.getElementById('bgResetBtn');
bgResetBtn.addEventListener('click', () => {
  localStorage.removeItem('bgImage'); // 保存したデータを削除
  // CSS変数を初期値に戻す
  document.documentElement.style.setProperty('--wall', 'none');
  document.documentElement.style.setProperty('--wallOpacity', 0);
}, {passive:true});
  
let voices=[], jpVoice=null, warmed=false;
// ★初期値は false。前回状態も復元できるように localStorage を参照
let charMode = (localStorage.getItem('charMode') ?? 'false') === 'true';

const voiceSel=document.getElementById('voiceSelect');
const charToggleBtn=document.getElementById('charToggleBtn');
  
  function uniqVoices(){
    const m=new Map();
    (speechSynthesis.getVoices()||[]).forEach(v=>{
      if(!/^ja(-|$)/i.test(v.lang)) return;
      const k=v.name+"|"+v.lang; if(!m.has(k)) m.set(k,v);
    }); return [...m.values()];
  }

  function populateVoices(){
    voices=uniqVoices(); voiceSel.innerHTML="";
    voices.forEach((v,i)=>{ const o=document.createElement('option'); o.value=i; o.textContent=`${v.name} (${v.lang})`; voiceSel.appendChild(o); });
    const idx=Math.max(0, voices.findIndex(v=>/kyoko|mizuki|nozomi|hina|sayaka|nanami|female|女/i.test(v.name)));
    voiceSel.selectedIndex=idx; jpVoice=voices[idx]||null;
  }
  voiceSel.addEventListener('change',()=>{ jpVoice=voices[voiceSel.selectedIndex]||null; });
  function warm(){ if(warmed) return; const u=new SpeechSynthesisUtterance(" "); u.lang="ja-JP"; u.volume=0; speechSynthesis.speak(u); warmed=true; }

  function sayOnce(text, opts={}){
  try { speechSynthesis.resume(); } catch(e){}
  const u = new SpeechSynthesisUtterance(text || " ");
  if (jpVoice) u.voice = jpVoice;
  u.lang = (jpVoice && jpVoice.lang) || "ja-JP";
  const rate  = parseFloat(document.getElementById('rate')?.value || "1.0");
  const pitch = parseFloat(document.getElementById('pitch')?.value || "1.0");
  u.rate  = opts.rate  ?? rate;
  u.pitch = opts.pitch ?? pitch;
  speechSynthesis.speak(u);
  return new Promise(res=>{ u.onend=res; u.onerror=res; });
}

  async function speakCharByChar(t){
    const a=Array.from(t);
    for(let i=0;i<a.length;i++){
      let ch=a[i];
      if(" 、。".includes(ch)){ await new Promise(r=>setTimeout(r,220)); continue; }
      if("？！!?".includes(ch)){ await new Promise(r=>setTimeout(r,300)); continue; }
      if(i<a.length-1 && "ゃゅょっー".includes(a[i+1])){ ch+=a[++i]; }
      await sayOnce(ch); 
      await new Promise(r=>setTimeout(r,40));
    }
  }
  
  function triggerEmojiAnimation(emojis) {
    const overlay = document.getElementById('animation-overlay');
    if (!overlay || !emojis) return;
    
    emojis.forEach((emoji, i) => {
      setTimeout(() => {
        const el = document.createElement('div');
        el.className = 'emoji-float';
        el.textContent = emoji;
        el.style.left = (Math.random() * 80 + 10) + '%';
        el.style.animationDuration = (Math.random() * 2 + 3) + 's';
        overlay.appendChild(el);
        el.addEventListener('animationend', () => { el.remove(); });
      }, i * 200);
    });
  }

  async function speak(){
    const t = display.textContent.trim();
    
    if(t === 'すき'){ triggerEmojiAnimation(['❤️']); }
    else if(t === 'だいすき'){ triggerEmojiAnimation(['❤️', '❤️', '❤️']); }
    else if(t === 'おめでとう'){ triggerEmojiAnimation(['🎉', '🥳', '🎊']); }
    else if(t === 'ありがとう'){ triggerEmojiAnimation(['😊', '🙏', '👍']); }
    else if(t === 'いいね'){ triggerEmojiAnimation(['👍']); }
    else if(t === 'ざんねん'){ triggerEmojiAnimation(['😢']); }
    else if(t === 'おはよう'){ triggerEmojiAnimation(['☀️']); }
    else if(t === 'こんにちは'){ triggerEmojiAnimation(['🤗']); }
    else if(t === 'こんばんは'){ triggerEmojiAnimation(['⭐']); }
      
    else if(t === 'ゆず'){ triggerEmojiAnimation(['⭐️', 'ゆず', '😃']); }
    else if(t === 'くるみ'){ triggerEmojiAnimation(['🎀', 'くるみ', '😉']); }
    else if(t === 'もね'){ triggerEmojiAnimation(['💖', 'もね', '😍']); }
    else if(t === 'はるか'){ triggerEmojiAnimation(['🌟', 'はるか', '🥰']); }
    else if(t === 'はると'){ triggerEmojiAnimation(['🕺', 'はると', '😎']); }
      
    else if(t === 'うんこ'){ triggerEmojiAnimation(['💩']); }
    else if(t === 'おなら'){ triggerEmojiAnimation(['💨']); }
    else if(t === 'おしり'){ triggerEmojiAnimation(['🫣']); }

    else if(t === 'ぞう'){ triggerEmojiAnimation(['🐘']); }
    else if(t === 'しまうま'){ triggerEmojiAnimation(['🦓']); }
    else if(t === 'きりん'){ triggerEmojiAnimation(['🦒']); }
    else if(t === 'ぱんだ'){ triggerEmojiAnimation(['🐼']); }
    else if(t === 'うさぎ'){ triggerEmojiAnimation(['🐰']); }
    else if(t === 'こあら'){ triggerEmojiAnimation(['🐨']); }
    else if(t === 'こぶた'){ triggerEmojiAnimation(['🐷']); }
    else if(t === 'きつね'){ triggerEmojiAnimation(['🦊']); }
    else if(t === 'ねこ'){ triggerEmojiAnimation(['🐱']); }
    else if(t === 'いぬ'){ triggerEmojiAnimation(['🐶']); }
    else if(t === 'かえる'){ triggerEmojiAnimation(['🐸']); }
    else if(t === 'らいおん'){ triggerEmojiAnimation(['🦁']); }
    else if(t === 'おさる'){ triggerEmojiAnimation(['🐒']); }
    else if(t === 'さる'){ triggerEmojiAnimation(['🐵']); }
    else if(t === 'ごりら'){ triggerEmojiAnimation(['🦍']); }
    else if(t === 'うし'){ triggerEmojiAnimation(['🐂']); }
   
    else if(t === 'ばあば'){ triggerEmojiAnimation(['👵']); }
    else if(t === 'じいじ'){ triggerEmojiAnimation(['👴']); }
    else if(t === 'はは'){ triggerEmojiAnimation(['🧓']); }
   
    else if(t === 'おばけ'){ triggerEmojiAnimation(['👻']); }

    if(!t) return; warm();

    if(charMode){ await speakCharByChar(t); return; }
    
    const parts = t.split(/([。！？!?])/);
    for(let i = 0; i < parts.length; i += 2){
      const seg = (parts[i] || "").trim();
      const p = (parts[i+1] || "");
      if(!seg && !p) continue;
      const excited = (p === "！" || p === "!");
      await sayOnce(seg + p, { rate: excited ? 1.12 : undefined, pitch: excited ? 1.18 : undefined });
    }
  }

function autoFit(){
  const vw = innerWidth, vh = innerHeight;
  const portrait = vh > vw;

  // デッキの左右パディング分（12px * 左右 + 内部 12px）
  const gutters = 12 + 12 + 12;
  const innerVW = Math.max(320, vw - gutters);

  // 縦（狭い）では1カラムなのでパネル幅は全幅、横では割合で決める
  let panelW;
  if (portrait && vw < 900) {
    panelW = innerVW;                    // 縦は下に回すので幅=100%
  } else {
    const ratio  = portrait ? 0.28 : 0.30;
    const minW   = portrait ? 170 : 190;
    const maxW   = portrait ? 300 : 320;
    panelW = Math.max(minW, Math.min(maxW, Math.round(innerVW * ratio)));
  }
  document.documentElement.style.setProperty('--panelW', panelW + 'px');

  const bw   = document.querySelector('.boardWrap');
  const leftW = bw.clientWidth;

  // まず現在の gap を取得
  const rootStyles = getComputedStyle(document.documentElement);
  let gap = parseInt(rootStyles.getPropertyValue('--gap')) || 10;

  // 7段（かな5 + 記号1 + 操作1）、横10列、間は6段/9列のギャップ
  const totalRows  = 7, totalGaps = 6, spacersHeight = 8 + 8;
  const rowsH = bw.clientHeight - spacersHeight;

  // 現在のギャップで試算
  let keyW = Math.floor((leftW - (10 - 1) * gap) / 10);
  let keyH = Math.floor((rowsH - totalGaps * gap) / totalRows);
  let key  = Math.min(keyW, keyH);

  // 狭すぎる時はギャップを詰める（6px）
  if (key < 50) {
    gap = 6;
    document.documentElement.style.setProperty('--gap', gap + 'px');
    keyW = Math.floor((leftW - (10 - 1) * gap) / 10);
    keyH = Math.floor((rowsH - totalGaps * gap) / totalRows);
    key  = Math.min(keyW, keyH);
  } else {
    document.documentElement.style.setProperty('--gap', '10px');
  }

  // 指の最小ターゲットを 36px まで許容
  key = Math.max(36, Math.min(104, key));
  document.documentElement.style.setProperty('--key', key + 'px');
  document.documentElement.style.setProperty('--okSize', key + 'px');
}

  document.getElementById('questionKey').addEventListener('click', ()=>insertText('？'), {passive:true});
  document.getElementById('spaceBtn').addEventListener('click', ()=>insertText(' '), {passive:true});
  document.getElementById('okActionBtn').addEventListener('click', speak, {passive:true});
  document.getElementById('backspaceBtn').addEventListener('click', ()=>{
    const a=[...display.textContent]; a.pop(); display.textContent=a.join('');
  }, {passive:true});
  document.getElementById('clearBtn').addEventListener('click', ()=>{ display.textContent=""; }, {passive:true});
  document.getElementById('reloadVoiceBtn').addEventListener('click', ()=>{ warmed=false; warm(); setTimeout(populateVoices,120); }, {passive:true});

  document.getElementById('tRed').addEventListener('click', ()=>setTheme('red'));
  document.getElementById('tBlue').addEventListener('click', ()=>setTheme('blue'));
  document.getElementById('tYellow').addEventListener('click', ()=>setTheme('yellow'));
  document.getElementById('tGreen').addEventListener('click', ()=>setTheme('green'));
  document.getElementById('tPink').addEventListener('click', ()=>setTheme('pink'));

  // ここも置き換え
function updateCharToggle(){
  charToggleBtn.classList.toggle('on', charMode);
  // ラベルをわかりやすく（任意）
  charToggleBtn.textContent = charMode ? 'ひともじずつよむ' : 'ふつうによむ';
}

document.getElementById('charToggleBtn').addEventListener('click', ()=>{
  charMode = !charMode;
  localStorage.setItem('charMode', String(charMode));   // ★保存
  updateCharToggle();
}, {passive:true});

  addEventListener('resize', autoFit); addEventListener('orientationchange', autoFit);

  function init(){
    buildKana(); buildSymbols(); buildTenkey(); setTheme('blue'); autoFit();
    if('speechSynthesis' in window){ 
      populateVoices(); 
      speechSynthesis.onvoiceschanged = populateVoices;
      setTimeout(populateVoices, 300);
      setTimeout(populateVoices, 1000);
    }
    updateCharToggle();
  }

function unlockTTS() {
  try {
    // Safari が paused なことがある
    speechSynthesis.resume();

    // 無音で一度キック
    const u = new SpeechSynthesisUtterance(" ");
    u.lang = "ja-JP";
    u.volume = 0;
    speechSynthesis.speak(u);
  } catch(e) {}

  // ボイスは何度か再取得（iOSは非同期で遅れてくることがある）
  populateVoices();
  setTimeout(populateVoices, 200);
  setTimeout(populateVoices, 800);

  // 1 回解錠したらリスナーは外す
  ['touchstart','mousedown','keydown'].forEach(ev=>{
    document.removeEventListener(ev, unlockTTS, true);
  });
}
// capture: true にして一度だけ
['touchstart','mousedown','keydown'].forEach(ev=>{
  document.addEventListener(ev, unlockTTS, { once:true, capture:true });
});

// タブ復帰時に勝手に pause されている対策
document.addEventListener('visibilitychange', ()=>{
  if (!document.hidden) { try { speechSynthesis.resume(); } catch(e){} }
});

  init();
})();
</script>
  
<script>
(function(){
  function updateOrientationGate(){
    const isPortrait = window.matchMedia("(orientation: portrait)").matches;
    document.body.classList.toggle('portrait', isPortrait);
  }
  // 初期化 & 画面変化で反映
  updateOrientationGate();
  addEventListener('resize', updateOrientationGate, {passive:true});
  addEventListener('orientationchange', updateOrientationGate, {passive:true});
})();
</script>

<script>
(function(){
  const appEl = document.querySelector('.app');
  function fitToViewport(){
    const vv = window.visualViewport;
    if (vv && appEl){
      appEl.style.height = vv.height + 'px';
    }
  }
  if (window.visualViewport){
    visualViewport.addEventListener('resize', fitToViewport);
    visualViewport.addEventListener('scroll', fitToViewport);
    fitToViewport();
  }
})();
</script>

<script>
if ('serviceWorker' in navigator) {
  window.addEventListener('load', () => {
    navigator.serviceWorker.register('./sw.js').catch(console.error);
  });
}
</script>

<div id="rotateGate" aria-hidden="true">
  <div class="rotateBox">
    📱 たて向きでは つかいにくいよ！<br>
    ＊ よこ向き に してね ＊
  </div>
</div>
  
</body>
</html>
